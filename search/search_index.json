{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Home","text":"<ul> <li> <p> Why Hyperflask ?</p> <p>Discover the project goals and technologies used</p> <p>Read more</p> </li> <li> <p> Get started</p> <p>Tutorial to create &amp; deploy your first Hyperflask project</p> <p>Start now</p> </li> <li> <p> In-depth guides</p> <p>Deep dive into Hyperflask and all its possibilities</p> <p>Read more</p> </li> </ul>"},{"location":"getting-started/","title":"Getting started","text":"<p>Welcome to Hyperflask! In this getting started guide will create a simple chat app with authentication.</p> <p>We will use Hyperflask-Start to create our project and VS Code as editor (as the starter template deeply integrates with it).</p> <p>What you will need:</p> <ul> <li>Docker</li> <li>VS Code</li> </ul> <p>If you are on Windows, use WSL.</p> <p>Python is not needed on your machine, everything will be executed inside containers.</p>"},{"location":"getting-started/#installation","title":"Installation","text":"<p>Launch the following command to create your project:</p> <pre><code>curl -L https://raw.githubusercontent.com/hyperflask/hyperflask-start/start.sh | bash\n</code></pre> <p>This will prompt you for some options and create the project in a new folder.</p> <p>Open your project folder in VS Code. It should prompt you to \"re-open workspace in development container\" which you should accept. VS Code will create and start the development container and re-launch itself.</p> <p>You are now developping from the container inside which you will find Python 3.11, Node &amp; npm and hyperflask installed.</p>"},{"location":"getting-started/#running-your-app","title":"Running your app","text":"<p>In VS Code, press F5 or \"Start debugging\" in the command palette.</p> <p>The browser will automatically open to your new site!</p>"},{"location":"getting-started/#first-look-at-the-code-base","title":"First look at the code base","text":"<p>In your project folder, you will find the following files and folders:</p> <ul> <li>app: your app code<ul> <li>assets: scripts and stylesheets that will be bundled using esbuild</li> <li>components: components to compose your app</li> <li>pages: your site pages</li> </ul> </li> <li>public: all files in this folder are publicly accessible</li> <li>tests: tests using pytest</li> <li>Dockerfile: Dockerfile to build your production image</li> <li>pyproject.toml: list python dependencies and tool options</li> <li>package.json: list javascript dependencies</li> <li>tailwind.config.js: tailwind configuration</li> </ul>"},{"location":"getting-started/#starting-our-chat-app","title":"Starting our chat app","text":"<p>First, let's add a <code>ChatMessage</code> component to render one message. In <code>app/components/ChatMessage.jpy</code>:</p> <pre><code>&lt;div class=\"message\"&gt;\n    {{props.message|markdown}}\n&lt;/div&gt;\n</code></pre> <p>The component is made of a jinja template. It receives a <code>props</code> variable that contains all the properties passed to the component.</p> <p>Info</p> <p>Note the <code>jpy</code> file extension which references a new file format named jinjapy</p> <p>Let's use this component, to render a thread. Replace the content of <code>app/pages/index.jpy</code> with the following:</p> <pre><code>{% use_layout %}\n&lt;div id=\"messages\"&gt;\n    &lt;{ChatMessage message=\"First message!\" }/&gt;\n    &lt;{ChatMessage message=\"Second message!\" }/&gt;\n&lt;/div&gt;\n</code></pre> <p>Here you can see that we are using a special syntax to call our component and pass it some props.</p> <p>Now we want to be able to send messages. We will add the ability to render messages through an HTTP call. Replace <code>app/components/ChatMessage.jpy</code> with the following:</p> <pre><code>---\nfrom hyperflask import request\n\ndef post():\n    return {\"message\": request.form[\"message\"]}\n---\n&lt;div class=\"message\"&gt;\n    {{props.message|markdown}}\n&lt;/div&gt;\n</code></pre> <p>We have added some python code in the frontmatter of the component. We define a <code>post</code> function that tells hyperflask that this component can receive POST requests.</p> <p>The function then returns the properties that will be used to render the component.</p> <p>Let's add a form to our chat interface. Replace <code>app/pages/index.jpy</code> with the following:</p> <pre><code>{% use_layout %}\n&lt;div id=\"messages\"&gt;\n    {# messages will display here #}\n&lt;/div&gt;\n&lt;{HxForm hx_post=url_for(\"ChatMessage\") hx_target=\"#messages\" hx_swap=\"beforeend\"}&gt;\n    &lt;{TextareaField name=\"message\" placeholder=\"Chat\" }/&gt;\n    &lt;{SubmitBtn}&gt;Send&lt;/{}&gt;\n&lt;/{HxForm}&gt;\n</code></pre> <p>We are using built-in hyperflask components to create our form and htmx to submit our form using AJAX.</p> <p>Using <code>hx-target</code> and <code>hx-swap</code> we are telling htmx to put the returned content from our component call at the end of the messages div.</p> <p>Try it now and chat with yourself!</p>"},{"location":"getting-started/#making-it-persistent","title":"Making it persistent","text":"<p>Now let's ensure that our chat is persisted and that reloading the page does not clear the chat history.</p> <p>Hyperflask uses sqlorm as its ORM.</p> <p>Create your first model. In <code>app/models.py</code>, add the following:</p> <pre><code>from hyperflask import db\nimport datetime\n\nclass Message(db.Model):\n    message: str\n    timestamp: datetime.datetime = db.Column(default=datetime.datetime.utcnow)\n</code></pre> <p>Modify our component to save messages:</p> <pre><code>---\nfrom hyperflask import request\nfrom app.models import db, Message\n\ndef post():\n    with db:\n        msg = Message.create(message=request.form[\"message\"])\n    return {\"message\": msg}\n---\n&lt;div class=\"message\"&gt;\n    {{props.message.message|markdown}}\n&lt;/div&gt;\n</code></pre> <p>And finally the page:</p> <pre><code>---\nfrom app.models import Message\n\npage.messages = Message.find_all()\n---\n{% use_layout %}\n&lt;div id=\"messages\"&gt;\n    {% for msg in messages %}\n        &lt;{ChatMessage message=msg }/&gt;\n    {% endfor %}\n&lt;/div&gt;\n&lt;{HxForm hx_post=url_for(\"ChatMessage\") hx_target=\"#messages\" hx_swap=\"beforeend\"}&gt;\n    &lt;{TextareaField name=\"message\" placeholder=\"Chat\" }/&gt;\n    &lt;{SubmitBtn}&gt;Send&lt;/{}&gt;\n&lt;/{HxForm}&gt;\n</code></pre>"},{"location":"getting-started/#adding-real-time-chat","title":"Adding real-time chat","text":"<p>Up until now, you could only chat with yourself. We will now refactor our app to become real-time.</p> <p>First, we will create a \"resource\" mapped to our <code>Message</code> model. Create <code>app/resources.py</code> with the following:</p> <pre><code>from hyperflask.resources import Resource\nfrom .models import Message\n\nclass MessageResource(Resource):\n    model = Message\n    url_prefix = \"/messages\"\n    macro = \"ChatMessage(message)\"\n</code></pre> <p>Note that using the <code>macro</code> prop, we are telling hyperflask to render this resource using our <code>ChatMessage</code> component by passing the object as the <code>message</code> prop.</p> <p>Info</p> <p>Why macro and not component ? Components are a layer above jinja macros. All defined components have a corresponding macro. But you can also define pure jinja macros.</p> <p>Modify the component back to its simpler state as message creation will now be handled via the resource:</p> <pre><code>&lt;div class=\"message\"&gt;\n    {{props.message.message|markdown}}\n&lt;/div&gt;\n</code></pre> <p>Finally, use the resource in the page:</p> <pre><code>---\nfrom app.resources import MessageResource\n\npage.messages = MessageResource.list()\n---\n{% use_layout %}\n&lt;div id=\"messages\"&gt;\n    {! messages !}\n&lt;/div&gt;\n&lt;{HxForm hx_post=messages.url() hx_swap=\"none\"}&gt;\n    &lt;{TextareaField name=\"message\" placeholder=\"Chat\" }/&gt;\n    &lt;{SubmitBtn}&gt;Send&lt;/{}&gt;\n&lt;/{HxForm}&gt;\n</code></pre> <p>We are now using a reactive directive to render our messages. Reactive directives use the resource system to add real-time reactivity to your page. In this case, this list of messages will be automatically updated as soon as we insert or delete messages.</p> <p>Notice also that we have changed the form action to post to the resource rather than the component. We are also ignoring the return of this call.</p> <p>Note</p> <p>Although it may feel like magic, reactive directives work in a well defined way:</p> <ul> <li>resources are exposed through a REST API (docs available at http://localhost:5000/api/docs)</li> <li>updates to resources are notified through an SSE stream</li> <li>on the frontend, it listens to the stream and updates the list accordingly</li> </ul> <p>Reactive directives work with any resource objects, whether list of them or their properties. However, using a non-resource object will print the value as usual.</p> <p>With a total of 27 lines of code, you now have a real-time and persisted chat room!</p>"},{"location":"getting-started/#adding-authentication","title":"Adding authentication","text":"<p>First, let's install the hyperflask-auth extension. In a VS Code terminal (while connected to the dev container), execute <code>poetry add hyperflask-auth</code>.</p> <p>As we will not deal with database migrations during this tutorial, delete your existing database: <code>rm databases/app.db</code>.</p> <p>Info</p> <p>Hyperflask-Auth provices login and signup pages as well as everything you need for a professional authentication flow.</p> <p>Let's create a user model and change our existing model to be bound to users:</p> <pre><code>from hyperflask import db\nfrom hyperflask_auth import UserMixin, UserRelatedMixin\nimport datetime\n\nclass User(UserMixin, db.Model):\n    pass\n\nclass Message(UserRelatedMixin, db.Model):\n    message: str\n    timestamp: datetime.datetime = db.Column(default=datetime.datetime.utcnow)\n</code></pre> <p>Modify the component to display the author:</p> <pre><code>&lt;div class=\"message\"&gt;\n    &lt;strong class=\"me-1\"&gt;{{props.message.user.username}}&lt;/strong&gt;\n    {{props.message.message|markdown}}\n&lt;/div&gt;\n</code></pre> <p>Finally, add <code>page.login_required()</code> at the top of your page frontmatter to require authentication to access it.</p>"},{"location":"getting-started/#deploying-to-production","title":"Deploying to production","text":"<p>Signup for an account on AWS or Digital Ocean (recommended), create a virtual machine, then run the following command from a VS Code terminal (while connected to the dev container):</p> <pre><code>hyperflask deploy\n</code></pre> <p>Your host information will be requested then the deployment will happen automatically. Connect to your domain and voil\u00e0!</p>"},{"location":"why/","title":"Why Hyperflask ?","text":"<p>The goal of the Hyperflask stack is to provide a single unified web stack, built on top of Python and proven technologies, where all components have been designed to work together seamlessly.</p> <p>It intends to provide solo devs and small teams a solution that allows them to build and operate a website/web app with minimal boilerplate and overhead. All the focus can go to work on the actual product.</p>"},{"location":"why/#key-goals","title":"Key goals","text":"<ul> <li>Full stack experience, from dev environment to UI framework to deployment</li> <li>All the tech choices have been made so you don't need to ask yourself tech stack questions</li> <li>Fully Open-Source stack that is 100% self-hostable if desired (no dependencies on cloud services)</li> <li>Use proven technologies and rely on standards as much as possible</li> <li>Backend driven with static content generation when needed</li> <li>Built for pragmatical but professional production apps</li> <li>Great developer experience and high productivity</li> <li>Beginner friendly but well engineered for advanced use cases</li> <li>Optimized for solo developers and small teams</li> <li>Can run on cheap machines or VMs from any server/cloud providers</li> <li>Respect privacy and limit data collection (GDPR compliant by default)</li> </ul>"},{"location":"why/#features-and-technologies","title":"Features and technologies","text":"<ul> <li>Web framework built on top of Flask as a set of extensions</li> <li>File-based and/or app-based routing</li> <li>A new file format combining python code in frontmatter and html templates to define routes</li> <li>SQL focused ORM with sqlorm, optimized for sqlite</li> <li>Modern asset pipeline using esbuild and tailwindcss</li> <li>Deep integration with htmx</li> <li>Easily create reusable backend and frontend components, compatible with Storybook</li> <li>Build frontend components using Web Components, Alpine.js, Stimulus and more. Mix technologies at will.</li> <li>Component library based on daisyUI with icons from Bootstrap Icons</li> <li>Seamless reactivity between frontend and backend</li> <li>Authentication and user management with social logins and MFA</li> <li>Static content collections to easily create blogs and manage static content</li> <li>File management with built-in image manipulation and S3 integration</li> <li>Template based emails with mjml support</li> <li>Background tasks using dramatiq</li> <li>Push support for realtime pages using server-sent events</li> <li>I18n using gettext</li> <li>Easily create REST APIs and automatically generate documentation</li> <li>Static, hybrid or dynamic modes for content serving</li> <li>Observable with OpenTelemetry</li> <li>Dev environment based on Development Containers</li> <li>Deep integration with VS Code with full support for interactive debugging</li> <li>Deployments using Ansible and Kamal</li> </ul>"},{"location":"why/#the-hyperflask-umbrella","title":"The Hyperflask umbrella","text":"<p>Many of the features of the Hyperflask framework are provided through Flask extensions and other libraries. A good portion of them are being developed under the Hyperflask umbrella. They are kept independant so they can be re-used in other projects outside of Hyperflask.</p> <p>Checkout the Github organization for the list of projects.</p>"},{"location":"why/#reasoning","title":"Reasoning","text":"<p>There are so many choices to make nowadays: what backend framework, what build tools, what frontend framework, how to deploy, how to easily develop locally, etc... The development world, and especially the javascript world, moves at a very fast pace which feels overwhelming and hard to keep track. There is a lot of good stuff happening but at the same time it often feels overwhelming.</p> <p>I think the \"SPA everything\" trend has reach its apogee. I never understood why use frontend component frameworks to build blogs as SPA apps. This trend is shifting back, with the rise of SSR in the javascript world.</p> <p>I do not find the direction React Server Components are following appealing. Blurring the line between frontend and backend has been tried before and it often leads to spaghetti code bases that are hard to maintain. Furthermore, I feel the backend building experience in javascript has never been great, far from python, php or rails.</p> <p>At the same time, I feel the developer experience is lacking in many areas. There's so many moving parts to learn and manage, it's daunting. It's especially hard for beginners.</p> <p>In the end, I love Python and Flask and want to continue building modern websites with them. Unfortunately, I felt a lot of extensions have become outdated and Flask being minimalist, no large scale frameworks around it. Hyperflask is my attempt to a super-powered Flask-based stack.</p> <p>Hyperflask aims to be the Laravel of the Python world.</p>"},{"location":"why/#acknowledgments","title":"Acknowledgments","text":"<p>Hyperflask is inspired by many:</p> <ul> <li>Ruby on Rails because of their backend-first, one man framework philosophy</li> <li>Astro for their page format, component islands and static content-first approach</li> <li>Jekyll for their content collections</li> <li>htmx for allowing to build web sites with minimal custom js</li> <li>Laravel for the everything included approach</li> <li>and many other open source projects</li> </ul>"},{"location":"components/buttons/","title":"Buttons","text":"<p>TODO</p>"},{"location":"components/forms/","title":"Forms","text":"<p>TODO</p>"},{"location":"guides/api/","title":"Building an API","text":""},{"location":"guides/app/","title":"Application","text":"<p>TODO</p>"},{"location":"guides/architecture/","title":"Architecture","text":"<p>TODO</p>"},{"location":"guides/assets/","title":"Assets","text":"<p>TODO</p> <p>In the meantime, see Flask-Assets-Pipeline</p>"},{"location":"guides/auth/","title":"Authentication","text":""},{"location":"guides/auth/#installation","title":"Installation","text":"<pre><code>poetry add hyperflask-auth\n</code></pre>"},{"location":"guides/auth/#setup","title":"Setup","text":"<p>TODO</p>"},{"location":"guides/collections/","title":"Collections","text":"<p>TODO</p> <p>In the meantime, see Flask-Collections</p>"},{"location":"guides/components/","title":"Components","text":"<p>TODO</p> <p>In the meantime, see Flask-Super-Macros</p>"},{"location":"guides/deploy/","title":"Deploy to production","text":"<p>TODO</p>"},{"location":"guides/emails/","title":"Emails","text":"<p>TODO</p> <p>In the meantime, see Flask-Mailman-Templates</p>"},{"location":"guides/forms/","title":"Forms","text":"<p>TODO</p> <p>In the meantime, see Jinja-WTForms</p>"},{"location":"guides/i18n/","title":"Internationalization","text":"<p>TODO</p> <p>In the meantime, see Flask-Babel-Plus</p>"},{"location":"guides/models/","title":"Models","text":"<p>TODO</p> <p>In the meantime, see Flask-SQLORM</p>"},{"location":"guides/pages/","title":"Pages","text":"<p>TODO</p> <p>In the meantime, see Flask-File-Routes</p>"},{"location":"guides/push/","title":"Server push","text":"<p>TODO</p> <p>In the meantime, see Flask-Mercure-SSE</p>"},{"location":"guides/pwa/","title":"Progressive Web Apps","text":"<p>TODO</p>"},{"location":"guides/resources/","title":"Resources","text":"<p>TODO</p>"},{"location":"guides/setup/","title":"Setup","text":""},{"location":"guides/setup/#requirements","title":"Requirements","text":"<p>Use Hyperflask-Start to create new projects and VS Code as editor (as the starter template deeply integrates with it).</p> <p>What you will need:</p> <ul> <li>Docker</li> <li>VS Code</li> </ul> <p>If you are on Windows, use WSL.</p> <p>Python is not needed on your machine, everything will be executed inside containers.</p>"},{"location":"guides/setup/#installation","title":"Installation","text":"<p>Launch the following command to create your project:</p> <pre><code>curl -L https://raw.githubusercontent.com/hyperflask/hyperflask-start/start.sh | bash\n</code></pre> <p>This will prompt you for some options and create the project in a new folder.</p>"},{"location":"guides/setup/#development-environment","title":"Development environment","text":"<p>Open your project folder in VS Code. It should prompt you to \"re-open workspace in development container\" which you should accept. VS Code will create and start the development container and re-launch itself.</p> <p>You are now developping from the container inside which you will find Python 3.11, Node &amp; npm and hyperflask installed.</p>"},{"location":"guides/structure/","title":"Project structure","text":"<p>TODO</p>"},{"location":"guides/tasks/","title":"Background tasks","text":"<p>TODO</p> <p>In the meantime, see Flask-Dramatiq</p>"},{"location":"recipes/analytics/","title":"Web &amp; product analytics","text":"<p>TODO</p>"},{"location":"recipes/monitoring/","title":"Monitoring","text":"<p>TODO</p>"},{"location":"recipes/sending-emails/","title":"Sending emails","text":"<p>TODO</p>"},{"location":"recipes/spa/","title":"Single Page Apps","text":""},{"location":"recipes/stripe/","title":"Stripe Checkout","text":"<p>TODO</p>"},{"location":"recipes/using-cms/","title":"Using a CMS","text":"<p>TODO</p>"}]}